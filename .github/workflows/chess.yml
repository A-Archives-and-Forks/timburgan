name: "Chess"

on:
  issues:
    types: [opened]

jobs:
  move:
    runs-on: ubuntu-latest
    if: startsWith(github.event.issue.title, 'chess|')
    steps:

    - name: Set env vars
      run: |
        echo ::set-env name=REPOSITORY::${{ github.repository }}
        echo ::set-env name=EVENT_ISSUE_NUMBER::${{ github.event.issue.number }}
        echo ::set-env name=EVENT_USER_LOGIN::${{ github.event.issue.user.login }}

      # We <3 Ruby, so let's use it + Octokit to ease the
      # scripting and API interactions.
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 2.7.1

    - name: Setup Gems
      run: |
        gem install activesupport -N --silent
        gem install octokit -N --silent
        gem install chess -N --silent


    - name: Play
      run: |
        ruby <<- EORUBY
          require 'active_support'
          require 'active_support/core_ext/object'
          require 'active_support/core_ext/array'
          require 'octokit'
          require 'chess'

          @preview_headers = [
            ::Octokit::Preview::PREVIEW_TYPES[:reactions],
            ::Octokit::Preview::PREVIEW_TYPES[:integrations]
          ]

          def error_notification(repo_nwo, issue_num, reaction, new_comment_body, e=nil)
            @octokit.create_issue_reaction(repo_nwo, issue_num, reaction, {accept: @preview_headers})
            @octokit.add_comment(repo_nwo, issue_num, new_comment_body)
            @octokit.close_issue(repo_nwo, issue_num)
            if e.present?
              puts '-----------'
              puts "Exception: #{e}"
              puts '-----------'
            end
          end
          def clean(string, alphanum_only=true)
            if alphanum_only
              string.downcase.gsub(/[^0-9A-Za-z]/, '')
            else
              string.downcase.gsub(/[^0-9A-Za-z \.]/, '')
            end
          end
          # Authenticate using GITHUB_TOKEN
          @octokit = Octokit::Client.new(access_token: "${{ secrets.GITHUB_TOKEN }}")
          @octokit.auto_paginate = true
          @octokit.default_media_type = ::Octokit::Preview::PREVIEW_TYPES[:integrations]
          # Show we've got eyes on the triggering comment.
          @octokit.create_issue_reaction(
            ENV.fetch('REPOSITORY'),
            ENV.fetch('EVENT_ISSUE_NUMBER'),
            'eyes',
            {accept: @preview_headers}
          )
          @octokit.create_issue_reaction(
            ENV.fetch('REPOSITORY'),
            ENV.fetch('EVENT_ISSUE_NUMBER'),
            'rocket',
            {accept: @preview_headers}
          )


          #
          # Parse the issue title.
          # ------------------------
          begin
              # validate we can parse title Chess|new|e3c2|1
              title_split = '${{ github.event.issue.title }}'.split('|')
              CHESS_GAME_NUM   = title_split&.fourth || ENV.fetch('EVENT_ISSUE_NUMBER').to_s
              CHESS_GAME_TITLE = title_split&.first.to_s + CHESS_GAME_NUM
              CHESS_GAME_CMD   = title_split&.second.to_s
              CHESS_USER_MOVE  = title_split&.third.to_s
              raise StandardError.new 'CHESS_GAME_TITLE is blank' if CHESS_GAME_TITLE.blank?
              raise StandardError.new 'CHESS_USER_MOVE is blank'  if CHESS_USER_MOVE.blank? && CHESS_GAME_CMD == 'move'
          rescue StandardError => e
              comment_text = "@#{ENV.fetch('EVENT_USER_LOGIN')} The game title or move was unable to be parsed."
              error_notification(ENV.fetch('REPOSITORY'), ENV.fetch('EVENT_ISSUE_NUMBER'), 'confused', comment_text, e)
              exit(0)
          end


          GAME_DATA_PATH = "chess_games/#{CHESS_GAME_TITLE}.pgn"


          #
          # Get the contents of the game board.
          # ---------------------------------------
          begin
              game_content = @octokit.contents(
                ENV.fetch('REPOSITORY'),
                path: GAME_DATA_PATH
              )&.content

              puts '----------------'
              puts game_content.to_s
              puts '----------------'

          rescue StandardError => e
              if CHESS_GAME_CMD == 'move'
                comment_text = "@#{ENV.fetch('EVENT_USER_LOGIN')} Game data couldn't be found: #{GAME_DATA_PATH}"
                error_notification(ENV.fetch('REPOSITORY'), ENV.fetch('EVENT_ISSUE_NUMBER'), 'confused', comment_text, e)
                exit(0)
              else
                #
                # no file exists... so no game... so... go ahead and create it
                # --------------------------------------
                game = Chess::Game.new
              end
          else
              #
              # Game is in progress. Load the game board.
              # ---------------------------------------
              begin
                  filename = "/tmp/chess_#{ENV.fetch('EVENT_ISSUE_NUMBER')}.pgn"
                  File.write filename, game_content

                  ## Load the current game
                  game = Chess::Game.load_pgn filename
              rescue StandardError => e
                  comment_text = "@#{ENV.fetch('EVENT_USER_LOGIN')} Game data couldn't loaded: #{GAME_DATA_PATH}"
                  error_notification(ENV.fetch('REPOSITORY'), ENV.fetch('EVENT_ISSUE_NUMBER'), 'confused', comment_text, e)
                  exit(0)
              end


              #
              # Perform Move
              # ---------------------------------------
              begin
                  puts game.move(CHESS_USER_MOVE) # ie move('e2e4', …, 'b1c3')
              rescue Chess::IllegalMoveError => e
                  comment_text = "@#{ENV.fetch('EVENT_USER_LOGIN')} Whaaa.. '#{CHESS_USER_MOVE}' is an invalid move!"
                  error_notification(ENV.fetch('REPOSITORY'), ENV.fetch('EVENT_ISSUE_NUMBER'), 'confused', comment_text, e)
                  exit(0)
              end


              #
              # Save the game board.
              # ---------------------------------------
              begin
                  @octokit.create_contents(
                    ENV.fetch('REPOSITORY'),
                    GAME_DATA_PATH,
                    "@#{ENV.fetch('EVENT_USER_LOGIN')} move #{CHESS_USER_MOVE}",
                    game.pgn.to_s,
                    branch: 'master',
                    sha:    "#{game_content.sha}"
                  )
              rescue StandardError => e
                  comment_text = "@#{ENV.fetch('EVENT_USER_LOGIN')} Couldn't save game data. Sorry."
                  error_notification(ENV.fetch('REPOSITORY'), ENV.fetch('EVENT_ISSUE_NUMBER'), 'confused', comment_text, e)
                  exit(0)
              end
          end

          puts game.status



          #
          # Update timburgan/timburgan/README.md
          # ---------------------------------------

          # visually represent the board
          # generate new comment links
          #   - and "what possible valid moves are for each piece"

          puts 'combos start:'
          puts Time.now

          cols = ('a'..'h').to_a
          rows = (1..8).to_a

          # list squares on the board - format a1, a2, a3, b1, b2, b3 etc
          squares = []
          cols.each do |col|
            rows.each do |row|
              squares.push "#{col}#{row}"
            end
          end

          # combine squares with where they  can MOVE to
          next_move_combos = squares.map { |from| {from: from, to: squares} }

          # delete squares not valid for next move
          valid_next_move_tester = game
          good_move = []
          next_move_combos.each do |square|
            square[:to].each do |to|
              begin
                move_command = "#{square[:from]}#{to}"
                valid_next_move_tester.move move_command
              rescue Chess::IllegalMoveError => e
                # remove that move from the list
                # next_move_combos = next_move_combos - [Hash[from, to]]
              else
                # move ok
                if good_move.select{ |move| move[:from] == square[:from] }.blank?
                  good_move.push({ from: square[:from], to: [to] })
                else
                  good_move.map do |move|
                    if move[:from] == square[:from]
                      {
                        from: move[:from],
                        to:   move[:to].push(to)
                      }
                    else
                      move
                    end
                  end
                end
              end
            end
          end


          puts '***** [217] **************'
          puts good_move.to_s
          puts '*******************'

          puts 'combos end:'
          puts Time.now




          game_state =  case game.status.to_s
                        when 'in_progress'
                          'Game is in progress.'
                        when 'white_won'
                          'Game won by white with a checkmate.'
                        when 'black_won'
                          'Game won by black with a checkmate.'
                        when 'white_won_resign'
                          'Game won by white for resign.'
                        when 'black_won_resign'
                          'Game won by black for resign.'
                        when 'stalemate'
                          'Game was a draw due to stalemate.'
                        when 'insufficient_material'
                          'Game was a draw due to insufficient material to checkmate.'
                        when 'fifty_rule_move'
                          'Game was a draw due to fifty rule move.'
                        when 'threefold_repetition'
                          'Game was a draw due to threshold repetition.'
                        else
                          'Game terminated. Something went wrong.'
                        end

          new_readme = <<~HTML

            ## Tim's Community Chess Tournament

            #{game_state}

          HTML

          pieces = {
            "K": "♔",
            "Q": "♕",
            "R": "♖",
            "B": "♗",
            "N": "♘",
            "P": "♙",
            "k": "♚",
            "q": "♛",
            "r": "♜",
            "b": "♝",
            "n": "♞",
            "p": "♟"
          }

          board = {
            "8": {
              a: { code: 56 },
              b: { code: 57 },
              c: { code: 58 },
              d: { code: 59 },
              e: { code: 60 },
              f: { code: 61 },
              g: { code: 62 },
              h: { code: 63 }
            },
            "7": {
              a: { code: 48 },
              b: { code: 49 },
              c: { code: 50 },
              d: { code: 51 },
              e: { code: 52 },
              f: { code: 53 },
              g: { code: 54 },
              h: { code: 55 }
            },
            "6": {
              a: { code: 40 },
              b: { code: 41 },
              c: { code: 42 },
              d: { code: 43 },
              e: { code: 44 },
              f: { code: 45 },
              g: { code: 46 },
              h: { code: 47 }
            },
            "5": {
              a: { code: 32 },
              b: { code: 33 },
              c: { code: 34 },
              d: { code: 35 },
              e: { code: 36 },
              f: { code: 37 },
              g: { code: 38 },
              h: { code: 39 }
            },
            "4": {
              a: { code: 24 },
              b: { code: 25 },
              c: { code: 26 },
              d: { code: 27 },
              e: { code: 28 },
              f: { code: 29 },
              g: { code: 30 },
              h: { code: 31 }
            },
            "3": {
              a: { code: 16 },
              b: { code: 17 },
              c: { code: 18 },
              d: { code: 19 },
              e: { code: 20 },
              f: { code: 21 },
              g: { code: 22 },
              h: { code: 23 }
            },
            "2": {
              a: { code: 8 },
              b: { code: 9 },
              c: { code: 10 },
              d: { code: 11 },
              e: { code: 12 },
              f: { code: 13 },
              g: { code: 14 },
              h: { code: 15 }
            },
            "1": {
              a: { code: 0 },
              b: { code: 1 },
              c: { code: 2 },
              d: { code: 3 },
              e: { code: 4 },
              f: { code: 5 },
              g: { code: 7 },
              h: { code: 8 }
            },
          }


          new_readme.concat "|  | A | B | C | D | E | F | G | H |\n"
          new_readme.concat "|- | - | - | - | - | - | - | - | - |\n"
          (1..8).to_a.reverse.each_with_index do |row|
            a = pieces[:"#{game.board[board[:"#{row}"][:a][:code]].to_s}"]
            b = pieces[:"#{game.board[board[:"#{row}"][:b][:code]].to_s}"]
            c = pieces[:"#{game.board[board[:"#{row}"][:c][:code]].to_s}"]
            d = pieces[:"#{game.board[board[:"#{row}"][:d][:code]].to_s}"]
            e = pieces[:"#{game.board[board[:"#{row}"][:e][:code]].to_s}"]
            f = pieces[:"#{game.board[board[:"#{row}"][:f][:code]].to_s}"]
            g = pieces[:"#{game.board[board[:"#{row}"][:g][:code]].to_s}"]
            h = pieces[:"#{game.board[board[:"#{row}"][:h][:code]].to_s}"]
            new_readme.concat "| #{row} | #{a} | #{b} | #{c} | #{d} | #{e} | #{f} | #{g} | #{h} |\n"
          end


          if game.over?
            new_readme.concat <<~HTML

              #### Play again? [Yep. New Game.](https://github.com/timburgan/timburgan/issues/new?title=chess%7Cnew)

            HTML
          else
            new_readme.concat <<~HTML

              #### **#{(game.board.active_color) ? 'BLACK' : 'WHITE'}:** It's your move... to choose _where_ to move..

              | FROM | TO _just click one of the links_ :) |
              | ---- | -- |
            HTML

            good_move.each do |move|
              new_readme.concat "| **#{move[:from].upcase}** | #{move[:to].map{|a| "[#{a.upcase}](https://github.com/timburgan/timburgan/issues/new?title=chess%7Cmove%7C#{move[:from]}#{a}%7C#{CHESS_GAME_NUM}&body=Just+push+%27Submit+new+issue%27.+You+don%27t+need+to+do+anything+else.)"}.join(', ')} |\n"
            end
          end

          new_readme.concat <<~HTML

            #### Moves so far

            | Date | Who | Move |
            | ---- | --- | ---- |
            | xx | @timburgan | a1b3 |


            #### Leaderboard

            **Most moves**

            | Moves | Who |
            | ----- | --- |
            | xx    | @timburgan |

            **Winning moves**

            | Moves | Who |
            | ----- | --- |
            | xx    | @timburgan |

          HTML


          puts new_readme



          #
          # Update the game with next moves.
          # ---------------------------------------
          begin
              current_readme_sha = @octokit.contents(
                'timburgan/timburgan',
                path: 'README.md'
              )&.sha

              puts '**** current readme *****************'
              puts current_readme_sha
              puts '*********************'

              @octokit.create_contents(
                'timburgan/timburgan',
                'README.md',
                "@#{ENV.fetch('EVENT_USER_LOGIN')} move #{CHESS_USER_MOVE}",
                new_readme,
                branch: 'master',
                sha:    current_readme_sha
              )
          rescue StandardError => e
              comment_text = "@#{ENV.fetch('EVENT_USER_LOGIN')} Couldn't update render of the game board. Move *was* saved, however."
              error_notification(ENV.fetch('REPOSITORY'), ENV.fetch('EVENT_ISSUE_NUMBER'), 'confused', comment_text, e)
              exit(0)
          end
